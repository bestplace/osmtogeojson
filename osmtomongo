#!/usr/bin/env node

var _ = require("lodash");
var fs = require('fs');
var through = require('through2');
var parseOSM = require('osm-pbf-parser');
var ProgressBar = require('ascii-progress');

var osmtogeojson = require('./'),
    opt = require('optimist')
        .usage('Usage: $0 [-f format] [-e] [-v] FILE')
        .boolean('bar').describe('bar', 'no progressbar')
        .boolean('main1').describe('main1', 'main1')
        .string('collection').describe('collection', 'features collections')
        .boolean('help').describe('help','print this help message'),
    argv = opt.argv,
    fs = require('fs'),
    concat = require('concat-stream'),
    osmpbfParser = require('tiny-osmpbf'),
    pack = require('./package.json');

var filename = argv._[0] || '';


var totalProcessed = 0;


var osm = parseOSM();
var osmItems = []

function main1() {
    const MB = 1024 * 1024;
    const stats = fs.statSync(filename)
    const fileSizeInMB = Math.round(stats.size / MB)
    var processedBytes = 0;
    var readBar = null;
    if (argv.bar) {
        readBar = new ProgressBar({schema: 'Reading: \t:bar Time: :time. Mem used: :mem, Data: :abs',  total: fileSizeInMB, width: 40 })
    }
    fs.createReadStream(filename)
        .pipe(through.obj(function(data, enc, next) {
            processedBytes += data.length;
            next(null, data);
        }))
        .pipe(osm)
        .pipe(through.obj(function (items, enc, next) {
            osmItems.push(...items)
            const processedMB = Number((processedBytes / MB).toFixed(1))
            const MBAbs = `processed ${processedMB}/${fileSizeInMB} MB`
            if (argv.bar) {
                readBar.update(processedMB / fileSizeInMB, {mem: usedMemory(), time: workTime(), abs: MBAbs});
            } else {
                console.log('Reading', osmItems.length, `processed ${MBAbs}`)
            }
            
            next();
        }))
        .on('finish', function () {
            console.log('total', osmItems.length)
            logUsedMemory();
            process.nextTick(convertParsedOSM, osmItems)
        });
}

function main2() {
    var datastream = fs.createReadStream(filename);
    datastream.pipe(concat(chunkedConvertPbf));
}

// if (argv.main1) {
//     main1();
// } else {
//     main2();
// }

main1();


function usedMemory() {
    const used = (process.memoryUsage().heapUsed / 1024 / 1024).toFixed(1);
    return `${used} MB`
}

function logUsedMemory() {
    console.log(`The script uses approximately ${usedMemory()}`);
}


var startTime = new Date();


function workTime() {
    var ms = new Date() - startTime;
    return `${Math.round(ms/1000)}s`;
}


function doneCallback() {
    console.log(`Job took: ${workTime()}`);
}


const CHUNK_SIZE = 10000;


function chunkedConvertPbf(data) {
    console.log('Total data size', data.length)
    data = osmpbfParser(data);

    console.log('Osm parsed size', data.elements.length)
    logUsedMemory();
    process.nextTick(convertParsedOSM, data.elements)
}


var MongoClient = require('mongodb').MongoClient;
var url = "mongodb://localhost:27017/";


function makeMongoSaver() {
    var MongoClient = require('mongodb').MongoClient;
    var MONGO_URL = "mongodb://localhost:27017/";
    var mongoDB = null;
    var database = null;

    function saveFeatures(features, callback) {
        if (!database) {
            MongoClient.connect(MONGO_URL, function(err, db) {
                if (err) {
                    throw err;
                }
                mongoDB = db;
                database = db.db('osm_import');
                process.nextTick(saveFeatures, features, callback)
            });
            return;
        }
        if (!features) {
            doneCallback()
            return mongoDB.close();
        } else if (features.length) {
            database.collection(argv.collection ||  "features").insert(features, function(err, res) {
                if (err) {
                    console.log(err);
                    throw err;
                }
                return callback();
            })
        } else {
            process.nextTick(callback);
        }
    }
    return saveFeatures;
}


function makeFileSaver() {
    var separator = argv.m ? '' : '\n';
    outStream = fs.createWriteStream('out.geojson')
    outStream.write('{'+separator+'"type": "FeatureCollection",'+separator+'"features": ['+separator);
    var totalCount = 0;

    return function(features, callback) {
        if (features) {
            features.forEach(function (feature) {
                outStream.write(totalCount > 0 ? ',\n' : '');
                outStream.write(JSON.stringify(feature, null, argv.m ? 0 : 2));
                totalCount++;
            })
        } else {
            outStream.write(separator+']'+separator+'}'+separator);
            outStream.end();
            doneCallback();
        }

        callback();
    }
}

function dummySaver() {
    return function(features, callback) {
        process.nextTick(callback)
        if (!features) {
            doneCallback();
        }
    }
}


function convertParsedOSM(elements) {
    var featureHandler = makeMongoSaver();
    var chunkConverter = osmtogeojson(elements, {});

    var bar = null;
    var lastStage = '';

    function handleProgress(context, chunkSize, total) {
        if (lastStage != context.stage.name) {
            if (argv.bar) {
                bar = new ProgressBar({schema: ':stage: \t:bar Time: :time. Mem used: :mem',  total: total, width: 40 })
            }
            lastStage = context.stage.name;
        }
        if (argv.bar) {
            bar.tick(chunkSize, {stage: lastStage, mem: usedMemory(), time: workTime()});
        } else {
            prentage = Math.round(100 * context.stage.processed/context.stage.total)
            console.log(`${context.stage.name} ${prentage}%. \tMem used: ${usedMemory()}`);
        }
    }

    function contextCallback(context, chunkSize, total) {
        handleProgress(context, chunkSize, total)
        global.gc();

        if (context.stage.name != 'done') {
            var features = context.featuresChunk;
            context.featuresChunk = new Array();
            
            return featureHandler(features, function() {
                process.nextTick(chunkConverter, contextCallback);
            })
        } else {
            return featureHandler(null, _.identity);
        }
    }

    chunkConverter(contextCallback);
}
